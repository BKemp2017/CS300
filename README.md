# CS300
This is a repository of my work done in CS300 DSA class

### What was the problem you were solving in the projects for this course?

This course required me to investigate various data structures and methods utilized in computer science. The major concepts were problem solving and determining the most effective ways to do it in various scenarios. I learnt about various sorting algorithms, how they might be implemented, how they operated, and how well or quickly they performed with data sets. I learnt about various data storage and access structures such as arrays, vectors, linked lists, hash tables, and binary search trees. When developing a binary search tree, I discovered about resursive functions that call themselves to aggregate a result, which I was able to apply extensively. All of this knowledge was acquired so that I could properly examine which data structures and methods would be most suited for loading a csv holding a college's course list, storing that information, and then sorting and presenting those courses in alphanumeric order.

### How did you approach the problem? Consider why data structures are important to understand?

I tackled the topic by examining each of the data structures and algorithms and assessing their performance in terms of basic activities such as creation/insertion, searching/access, sorting, and printing. Memory utilization can also play a role in the examination of data structures and algorithms, but because this project was on such a tiny scale with nearly limitless resources, memory limits were ignored. However, it is always vital to understand the data that your program will be dealing with, such as the size and volume, as well as the hardware that the application will operate on, to ensure that it will function effectively and efficiently.

### How did you overcome any roadblocks you encountered while going through the activities or project?

When I hit a snag, I relied on a few key resources. My initial reaction is to attempt to troubleshoot the problem myself, either by setting a breakpoint where the problematic code is or by adding extra console logs to check which branches the program is traversing or not traversing. I also discovered a lot of relevant examples and references to algorithms and data structures in the course's zybooks content. In many situations, reading and rereading the material helped to consolidate notions. When I required a little more information, I would do a Google search for the exact issue and then read through 3-6 postings on the topic, making sure to go over the acceptable responses as well as a lot of additional input from other people. When I obtain advice from sites like stack overflow, I usually make sure to digest as much information as possible on the page before returning to my own work and attempting to implement the things that made the most sense rather than simply copying and pasting the acceptable solution.

### How has your work on this project expanded your approach to designing software and developing programs?

Prior to this course, I was aware of and used hash maps/dictionaries, but I had no idea how they functioned or how to use them. Furthermore, because the majority of my programming expertise has been in languages such as Python, JavaScript, and C++, I had never heard of or utilized linked lists before. I had only heard about binary search trees and understood very little about them, so knowing how to design all of these structures was a skill that I felt really helped me grasp how and why they are employed. The sorting algorithms part was also incredibly helpful because I had no idea how to construct fast sort or radix sort, for example, and had to rely on the implementations provided by the language(s) provided. After taking this course, I am more eager to build and find novel methods to address various issues in Computer Science, and my overall skill set has increased.

### How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
For the final project, I made care to split my source code into various files so that I could easily create and manage it. For some of the early tasks in the course, everything was in one source code file, mostly for the simplicity of handing them in to the professor to be assessed, but I would prefer to have everything in their own area. This helps me keep track of where I need to update certain lines of code, and it also helps with compile time: breaking up the program into self-contained pieces means that the entire code-base doesn't need to be recompiled every time there's an independent change someplace else. Commenting lines of code and providing function explanations is another ability I've honed throughout my time at SNHU. In my hobby projects, I usually code as much as I can without worrying about commenting the code, but I've been guilty of returning to my code months or years later and having a hard time remembering how things worked or what certain lines of code were doing, so I've learned that the hard way, but it's something I feel more confident in now that I've made sure to comment frequently.
